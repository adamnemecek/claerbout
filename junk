

	#  Scaled linear interpolation.
	#
	subroutine spotw( adj, add, scale, nt,t0,dt, t, val,   vec   )
	integer it,itc,   adj, add,        nt
	real tc, fraction,          scale,    t0,dt, t, val,   vec(nt)

	call adjnull(     adj, add,                     val,1, vec,nt)

	tc = .5+ (t-t0) / dt;	itc = tc;     it = 1 + itc;
	fraction = tc - itc

	if( adj == 0) {
		vec(it  ) = vec(it  ) + (1.-fraction) * val * scale
		vec(it+1) = vec(it+1) +   fraction    * val * scale
		}
	else
		val = val + ((1.-fraction) * vec(it)  +
			       fraction    * vec(it+1)  ) * scale
	return;	end



	# moveout with triangle shaped smoothing window.
	#
	subroutine trimo(  adj, add, t0,dt, dx,x, nt, slow, s02, wt, anti, zz,    tt )
	integer iz,itp,itm,adj, add,              nt
	real                         t0,dt, dx,x, slow(nt), s02, wt, anti, zz(nt),tt(nt)
	real z, t,tm,tp, amp, slope
	temporary real ss(nt)

	call null(     ss,nt);	call adjnull( adj, add,                    zz,nt, tt,nt)

	if( adj != 0 )		call doubint( 1, 0, nt, ss, tt)

	do iz= 2, nt {	z = t0 + dt * (iz-1)

		t = sqrt( z**2 + (slow(iz) * x)**2 )

		slope = anti * ( slow(iz)**2 - s02 ) * x / t

		tp = t + abs(slope * dx) + dt;	 itp = 1.5 + (tp-t0) / dt
		tm = t - abs(slope * dx) - dt;	 itm = 1.5 + (tm-t0) / dt

		if( itm <= 1  )  next
		if( itp >= nt )  break

		amp = wt * sqrt( nt*dt/t) * z/t * (dt/(dt+tp-tm)) ** 2

		call spotw( adj, 1,  -amp, nt,t0,dt,tm, zz(iz), ss)
		call spotw( adj, 1, 2*amp, nt,t0,dt,t , zz(iz), ss)
		call spotw( adj, 1,  -amp, nt,t0,dt,tp, zz(iz), ss)
		}

	if( adj == 0)		call doubint( 0, add, nt, ss, tt)

	return; end
